(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{792:function(t,_,v){"use strict";v.r(_);var r=v(14),e=Object(r.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey},scopedSlots:t._u([{key:"abstract",fn:function(){return[_("p",[t._v("CSS图层：浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点，也就是我们各种各样的Dom标签。")]),t._v(" "),_("p",[t._v("在渲染DOM的时候，浏览器所做的工作实际上是：")]),t._v(" "),_("ul",[_("li",[t._v("获取DOM后分割为多个图层")]),t._v(" "),_("li",[t._v("对每个图层的节点计算样式结果 （Recalculate style–样式重计算）")]),t._v(" "),_("li",[t._v("为每个节点生成图形和位置 （Layout–布局，重排,回流）")]),t._v(" "),_("li",[t._v("将每个节点绘制填充到图层位图中 （Paint–重绘）")]),t._v(" "),_("li",[t._v("图层作为纹理上传至GPU")]),t._v(" "),_("li",[t._v("组合多个图层到页面上生成最终屏幕图像 （Composite Layers–图层重组）")])]),t._v(" "),_("blockquote",[_("p",[t._v("需要不需要虚拟DOM，其实与框架的DOM操作机制有关")])])]},proxy:!0}])},[_("h2",{attrs:{id:"重绘"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[t._v("#")]),t._v(" 重绘")]),t._v(" "),_("p",[t._v("重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们将这样的操作称为重绘。")]),t._v(" "),_("p",[t._v("需要注意的是：重绘是以图层为单位，如果图层中某个元素需要重绘，那么整个图层都需要重绘。所以为了提高性能，我们应该让这些“变化的东西”拥有一个自己一个图层，不过好在绝大多数的浏览器自己会为CSS3动画的节点自动创建图层。")]),t._v(" "),_("h2",{attrs:{id:"回流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#回流"}},[t._v("#")]),t._v(" 回流")]),t._v(" "),_("p",[t._v("当render tree中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就称为回流。")]),t._v(" "),_("p",[t._v("每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。")]),t._v(" "),_("p",[t._v("在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。")]),t._v(" "),_("h2",{attrs:{id:"区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),_("ul",[_("li",[t._v("回流必将引起重绘，而重绘不一定引起回流。比如只有颜色改变时，就只会发生重绘而不会发生回流")]),t._v(" "),_("li",[t._v("当页面布局和几何属性改变时就需要回流。比如：添加或删除可见的DOM元素，元素位置改变，元素尺寸改变-边距、填充、边框、宽度和高度，内容改变。")])])])}),[],!1,null,null,null);_.default=e.exports}}]);